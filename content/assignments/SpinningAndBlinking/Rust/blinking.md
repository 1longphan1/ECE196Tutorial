---
title: Blinking
type: docs
prev: assignments/SpinningAndBlinking/Setup
weight: 2
---

Well... this is awkward. The board is already blinking!

*But how?*

Let's look line by line to understand how this is working.

Navigate to `firmware/src/main.rs`. This is the main file for our firmware.

```rust
#![no_std]
#![no_main]
```

At the top of the file you will find ^ these directives.

`#![no_std]` indicates that our program will *not* have acces to the Rust
standard library. This is because embedded systems are resource constrained
environments with no operating system, so simple things like allocation are
suddenly not so simple. This directive informs the Rust compiler that the
standard library is unavailable, which permits us to target the microcontroller.

`#![no_main]` indicates that the entry-point[^1] to our program is non-trivial.
The Rust compiler typically expects the entry-point to be defined as a top-level[^2]
function named `main`, however as we will soon see, the entry-point will not be
defined by us, and will be generated by Embassy to begin async operation and start
the executor[^3].

[^1]: All binaries have an entry-point, which is the symbol to start execution on.
[^2]: A top-level item is defined above all hierarchy of a file. Think of global
variable definitions, free-standing functions or type definitions.
[^3]: The *executor* is the "entity" provided by Embassy that fascilitates the
routing of execution between tasks.
